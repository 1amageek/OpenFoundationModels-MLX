import Testing
@testable import OpenFoundationModelsMLX

@Suite struct TokenTrieTests {
    
    // MARK: - Mock Tokenizer
    
    /// Mock tokenizer for testing - provides predictable token IDs
    struct MockTokenizer: TokenizerAdapter {
        /// Simple mapping: each character gets its ASCII value as token ID
        func encode(_ text: String) -> [Int32] {
            return text.compactMap { char in
                guard let ascii = char.asciiValue else { return nil }
                return Int32(ascii)
            }
        }
        
        func decode(_ ids: [Int32]) -> String {
            return String(ids.compactMap { id in
                guard id > 0 && id <= 127 else { return nil }
                return Character(UnicodeScalar(Int(id))!)
            })
        }
        
        func getVocabSize() -> Int? {
            return 128 // ASCII range
        }
    }
    
    // MARK: - Basic Functionality Tests
    
    @Suite struct BasicFunctionalityTests {
        
        @Test func initializesEmpty() {
            let trie = TokenTrie()
            #expect(trie.allKeys.isEmpty)
            #expect(trie.allowedNext(from: []) != nil)
        }
        
        @Test func insertsBasicTokenSequence() {
            var trie = TokenTrie()
            let tokens: [Int32] = [65, 66, 67] // "ABC"
            
            trie.insert(tokenIDs: tokens, keyName: "test")
            
            #expect(trie.allKeys.contains("test"))
            #expect(trie.node(for: tokens) != nil)
            #expect(trie.node(for: tokens)?.terminal == true)
            #expect(trie.node(for: tokens)?.keyName == "test")
        }
        
        @Test func insertsMultipleSequences() {
            var trie = TokenTrie()
            let seq1: [Int32] = [65, 66] // "AB"
            let seq2: [Int32] = [67, 68] // "CD"
            
            trie.insert(tokenIDs: seq1, keyName: "key1")
            trie.insert(tokenIDs: seq2, keyName: "key2")
            
            #expect(trie.allKeys.count == 2)
            #expect(trie.allKeys.contains("key1"))
            #expect(trie.allKeys.contains("key2"))
            #expect(trie.node(for: seq1)?.terminal == true)
            #expect(trie.node(for: seq2)?.terminal == true)
        }
        
        @Test func handlesOverlappingSequences() {
            var trie = TokenTrie()
            let seq1: [Int32] = [65, 66] // "AB"
            let seq2: [Int32] = [65, 66, 67] // "ABC" - extends seq1
            
            trie.insert(tokenIDs: seq1, keyName: "short")
            trie.insert(tokenIDs: seq2, keyName: "long")
            
            #expect(trie.allKeys.count == 2)
            #expect(trie.node(for: seq1)?.terminal == true)
            #expect(trie.node(for: seq1)?.keyName == "short")
            #expect(trie.node(for: seq2)?.terminal == true)
            #expect(trie.node(for: seq2)?.keyName == "long")
        }
        
        @Test func handlesCommonPrefixes() {
            var trie = TokenTrie()
            let name: [Int32] = [110, 97, 109, 101] // "name"
            let namePrefix: [Int32] = [110, 97, 109, 101, 95] // "name_"
            
            trie.insert(tokenIDs: name, keyName: "name")
            trie.insert(tokenIDs: namePrefix, keyName: "name_prefix")
            
            let nameResult = trie.allowedNext(from: name)
            #expect(nameResult != nil)
            #expect(nameResult?.atTerminal == true)
            #expect(nameResult?.ids.contains(95) == true) // underscore continues to name_prefix
        }
        
        @Test func retrievesAllowedTokens() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65, 66], keyName: "ab")
            trie.insert(tokenIDs: [65, 67], keyName: "ac")
            
            // At root, should allow 'A' (65)
            let rootResult = trie.allowedNext(from: [])
            #expect(rootResult?.ids == [65])
            #expect(rootResult?.atTerminal == false)
            
            // After 'A', should allow 'B' (66) or 'C' (67)
            let afterA = trie.allowedNext(from: [65])
            #expect(afterA?.ids == [66, 67])
            #expect(afterA?.atTerminal == false)
            
            // After 'AB' or 'AC', should be terminal with no next tokens
            let afterAB = trie.allowedNext(from: [65, 66])
            #expect(afterAB?.ids.isEmpty == true)
            #expect(afterAB?.atTerminal == true)
        }
        
        @Test func handlesNonExistentPaths() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65, 66], keyName: "ab")
            
            // Path that doesn't exist
            let result = trie.allowedNext(from: [99, 100])
            #expect(result == nil)
            
            // Partial path that doesn't exist
            let partialResult = trie.allowedNext(from: [65, 99])
            #expect(partialResult == nil)
        }
    }
    
    // MARK: - Edge Case Tests
    
    @Suite struct EdgeCaseTests {
        
        @Test func handlesEmptyTokenSequence() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [], keyName: "empty")
            
            // Empty sequence should not be inserted
            #expect(!trie.allKeys.contains("empty"))
            #expect(trie.node(for: [])?.terminal == false)
        }
        
        @Test func handlesNilKeyName() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65], keyName: nil)
            
            let node = trie.node(for: [65])
            #expect(node?.terminal == true)
            #expect(node?.keyName == nil)
            #expect(trie.allKeys.isEmpty)
        }
        
        @Test func handlesEmptyKeyName() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65], keyName: "")
            
            #expect(!trie.allKeys.contains(""))
            #expect(trie.node(for: [65])?.keyName == "")
        }
        
        @Test func handlesDuplicateInsertions() {
            var trie = TokenTrie()
            let tokens: [Int32] = [65, 66]
            
            trie.insert(tokenIDs: tokens, keyName: "first")
            trie.insert(tokenIDs: tokens, keyName: "second") // overwrites
            
            #expect(trie.allKeys.count == 2) // Both keys tracked
            #expect(trie.node(for: tokens)?.keyName == "second") // Latest wins
            #expect(trie.node(for: tokens)?.terminal == true)
        }
        
        @Test func handlesExtremeTokenValues() {
            var trie = TokenTrie()
            let extremeTokens: [Int32] = [Int32.min, 0, Int32.max]
            
            trie.insert(tokenIDs: extremeTokens, keyName: "extreme")
            
            #expect(trie.node(for: extremeTokens)?.terminal == true)
            #expect(trie.node(for: extremeTokens)?.keyName == "extreme")
        }
        
        @Test func handlesVeryLongSequences() {
            var trie = TokenTrie()
            let longSequence = Array(1...1000) // 1000 tokens
            
            trie.insert(tokenIDs: longSequence, keyName: "long")
            
            #expect(trie.node(for: longSequence)?.terminal == true)
            #expect(trie.node(for: longSequence)?.keyName == "long")
        }
        
        @Test func handlesVeryLongKeyName() {
            var trie = TokenTrie()
            let longKey = String(repeating: "a", count: 10000)
            
            trie.insert(tokenIDs: [1, 2, 3], keyName: longKey)
            
            #expect(trie.allKeys.contains(longKey))
            #expect(trie.node(for: [1, 2, 3])?.keyName == longKey)
        }
    }
    
    // MARK: - Path Operation Tests
    
    @Suite struct PathOperationTests {
        
        @Test func initializesPathCorrectly() {
            let trie = TokenTrie()
            let path = TokenTrie.Path()
            
            #expect(path.tokens.isEmpty)
            #expect(!path.isValid())
            #expect(!path.isAtTerminal())
            #expect(path.getKeyName() == nil)
        }
        
        @Test func initializesPathWithRoot() {
            let trie = TokenTrie()
            let path = TokenTrie.Path(root: trie.root)
            
            #expect(path.tokens.isEmpty)
            #expect(path.isValid())
            #expect(!path.isAtTerminal())
        }
        
        @Test func appendsValidTokens() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65, 66, 67], keyName: "abc")
            
            var path = TokenTrie.Path(root: trie.root)
            
            let result1 = path.append(65, in: trie)
            #expect(result1 == true)
            #expect(path.tokens == [65])
            #expect(path.isValid())
            
            let result2 = path.append(66, in: trie)
            #expect(result2 == true)
            #expect(path.tokens == [65, 66])
            #expect(path.isValid())
            
            let result3 = path.append(67, in: trie)
            #expect(result3 == true)
            #expect(path.tokens == [65, 66, 67])
            #expect(path.isValid())
            #expect(path.isAtTerminal())
            #expect(path.getKeyName() == "abc")
        }
        
        @Test func rejectsInvalidTokens() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65, 66], keyName: "ab")
            
            var path = TokenTrie.Path(root: trie.root)
            
            let result1 = path.append(65, in: trie)
            #expect(result1 == true) // Valid: goes to 'A'
            
            let result2 = path.append(99, in: trie)
            #expect(result2 == false) // Invalid: 'A' + 'c' not in trie
            
            // Path should remain in last valid state
            #expect(path.tokens == [65])
            #expect(path.isValid())
        }
        
        @Test func resetsPathCorrectly() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65, 66], keyName: "ab")
            
            var path = TokenTrie.Path(root: trie.root)
            let _ = path.append(65, in: trie)
            let _ = path.append(66, in: trie)
            
            #expect(path.tokens.count == 2)
            
            path.reset(to: trie.root)
            
            #expect(path.tokens.isEmpty)
            #expect(path.isValid())
            #expect(!path.isAtTerminal())
        }
        
        @Test func handlesPathFromEmptyState() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65], keyName: "a")
            
            var path = TokenTrie.Path() // No root
            
            // Should be able to start from empty state
            let result = path.append(65, in: trie)
            #expect(result == true)
            #expect(path.tokens == [65])
            #expect(path.isValid())
        }
        
        @Test func getAllowedTokensFromPath() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65, 66], keyName: "ab")
            trie.insert(tokenIDs: [65, 67], keyName: "ac")
            
            let rootPath = TokenTrie.Path(root: trie.root)
            let rootTokens = trie.getAllowedTokens(for: rootPath)
            #expect(rootTokens == [65])
            
            var pathAfterA = TokenTrie.Path(root: trie.root)
            let _ = pathAfterA.append(65, in: trie)
            let tokensAfterA = trie.getAllowedTokens(for: pathAfterA)
            #expect(tokensAfterA == [66, 67])
        }
        
        @Test func canCompleteFromPath() {
            var trie = TokenTrie()
            trie.insert(tokenIDs: [65, 66], keyName: "ab")
            
            var path = TokenTrie.Path(root: trie.root)
            #expect(!trie.canComplete(from: path)) // At root, not terminal
            
            let _ = path.append(65, in: trie)
            #expect(!trie.canComplete(from: path)) // After A, not terminal
            
            let _ = path.append(66, in: trie)
            #expect(trie.canComplete(from: path)) // After AB, terminal
        }
    }
    
    // MARK: - TokenTrieBuilder Tests
    
    @Suite struct TokenTrieBuilderTests {
        
        @Test func buildsFromKeyArray() {
            let tokenizer = MockTokenizer()
            let keys = ["name", "age", "email"]
            
            let trie = TokenTrieBuilder.build(keys: keys, tokenizer: tokenizer)
            
            #expect(trie.allKeys == Set(keys))
            
            // Test that each key can be traversed
            for key in keys {
                let tokens = tokenizer.encode(key)
                #expect(trie.node(for: tokens)?.terminal == true)
                #expect(trie.node(for: tokens)?.keyName == key)
            }
        }
        
        @Test func filtersEmptyKeys() {
            let tokenizer = MockTokenizer()
            let keys = ["name", "", "age", " "] // Include empty and whitespace
            
            let trie = TokenTrieBuilder.build(keys: keys, tokenizer: tokenizer)
            
            // Should only include non-empty keys
            #expect(trie.allKeys.count == 2)
            #expect(trie.allKeys.contains("name"))
            #expect(trie.allKeys.contains("age"))
            #expect(!trie.allKeys.contains(""))
            #expect(!trie.allKeys.contains(" "))
        }
        
        @Test func handlesDuplicateKeys() {
            let tokenizer = MockTokenizer()
            let keys = ["name", "age", "name", "email", "age"] // Duplicates
            
            let trie = TokenTrieBuilder.build(keys: keys, tokenizer: tokenizer)
            
            // Should deduplicate
            #expect(trie.allKeys.count == 3)
            #expect(trie.allKeys.contains("name"))
            #expect(trie.allKeys.contains("age"))
            #expect(trie.allKeys.contains("email"))
        }
        
        @Test func buildsFromSchemaMeta() {
            let tokenizer = MockTokenizer()
            let schema = SchemaMeta(keys: ["user", "pass"], required: ["user"])
            
            let trie = TokenTrieBuilder.build(from: schema, tokenizer: tokenizer)
            
            #expect(trie.allKeys == Set(schema.keys))
            
            // Verify both keys are properly encoded
            for key in schema.keys {
                let tokens = tokenizer.encode(key)
                #expect(trie.node(for: tokens)?.terminal == true)
                #expect(trie.node(for: tokens)?.keyName == key)
            }
        }
        
        @Test func cachesMemoizedBuild() {
            let tokenizer = MockTokenizer()
            let schema = SchemaMeta(keys: ["cached"], required: [])
            
            // Build twice with same schema
            let trie1 = TokenTrieBuilder.buildCached(schema: schema, tokenizer: tokenizer)
            let trie2 = TokenTrieBuilder.buildCached(schema: schema, tokenizer: tokenizer)
            
            // Should be functionally equivalent (though not necessarily the same object)
            #expect(trie1.allKeys == trie2.allKeys)
            
            // Verify functionality
            let tokens = tokenizer.encode("cached")
            #expect(trie1.node(for: tokens)?.terminal == true)
            #expect(trie2.node(for: tokens)?.terminal == true)
        }
        
        @Test func handlesComplexKeys() {
            let tokenizer = MockTokenizer()
            let keys = [
                "simple",
                "with_underscore", 
                "with-dash",
                "with123numbers",
                "UPPERCASE",
                "mixedCase"
            ]
            
            let trie = TokenTrieBuilder.build(keys: keys, tokenizer: tokenizer)
            
            #expect(trie.allKeys == Set(keys))
            
            // Verify all keys can be found
            for key in keys {
                let tokens = tokenizer.encode(key)
                #expect(trie.node(for: tokens)?.terminal == true)
                #expect(trie.node(for: tokens)?.keyName == key)
            }
        }
    }
    
    // MARK: - Memory and Performance Edge Cases
    
    @Suite struct MemoryTests {
        
        @Test func handlesLargeNumberOfKeys() {
            let tokenizer = MockTokenizer()
            let keys = (1...1000).map { "key_\($0)" }
            
            let trie = TokenTrieBuilder.build(keys: keys, tokenizer: tokenizer)
            
            #expect(trie.allKeys.count == 1000)
            
            // Spot check a few keys
            let testKeys = ["key_1", "key_500", "key_1000"]
            for key in testKeys {
                let tokens = tokenizer.encode(key)
                #expect(trie.node(for: tokens)?.terminal == true)
                #expect(trie.node(for: tokens)?.keyName == key)
            }
        }
        
        @Test func handlesDeepNesting() {
            var trie = TokenTrie()
            
            // Create a very deep path (50 levels)
            let deepTokens = Array(1...50)
            trie.insert(tokenIDs: deepTokens, keyName: "deep")
            
            #expect(trie.node(for: deepTokens)?.terminal == true)
            #expect(trie.node(for: deepTokens)?.keyName == "deep")
            
            // Verify intermediate nodes exist but aren't terminal
            for i in 1..<50 {
                let partialPath = Array(deepTokens[0..<i])
                let node = trie.node(for: partialPath)
                #expect(node != nil)
                #expect(node?.terminal == false)
            }
        }
        
        @Test func handlesWideBranching() {
            var trie = TokenTrie()
            
            // Create many branches from root (100 different first tokens)
            for i in 1...100 {
                trie.insert(tokenIDs: [Int32(i), Int32(i+1000)], keyName: "branch_\(i)")
            }
            
            #expect(trie.allKeys.count == 100)
            
            // Root should have 100 children
            let rootResult = trie.allowedNext(from: [])
            #expect(rootResult?.ids.count == 100)
            
            // Spot check a few branches
            for i in [1, 50, 100] {
                let tokens = [Int32(i), Int32(i+1000)]
                #expect(trie.node(for: tokens)?.terminal == true)
                #expect(trie.node(for: tokens)?.keyName == "branch_\(i)")
            }
        }
    }
}
