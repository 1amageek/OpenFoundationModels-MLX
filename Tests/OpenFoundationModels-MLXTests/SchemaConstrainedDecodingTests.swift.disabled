import Testing
@testable import OpenFoundationModelsMLX

@Suite struct SchemaConstrainedDecodingTests {
    
    // MARK: - JSONKeyTracker Tests
    
    @Suite struct JSONKeyTrackerTests {
        @Test func tracksValidJSONProgression() {
            var tracker = JSONKeyTracker(keys: ["name", "age"])
            
            // Build valid JSON step by step
            #expect(tracker.processChar("{") == .continue)
            #expect(tracker.processChar("\"") == .continue)
            #expect(tracker.processChar("n") == .continue)
            #expect(tracker.processChar("a") == .continue)
            #expect(tracker.processChar("m") == .continue)
            #expect(tracker.processChar("e") == .continue)
            #expect(tracker.processChar("\"") == .continue)
            #expect(tracker.processChar(":") == .continue)
        }
        
        @Test func detectsNoKeyCandidatesEarly() {
            var tracker = JSONKeyTracker(keys: ["name", "age"])
            
            // Start with invalid key
            #expect(tracker.processChar("{") == .continue)
            #expect(tracker.processChar("\"") == .continue)
            #expect(tracker.processChar("x") == .continue)
            #expect(tracker.processChar("y") == .continue)
            #expect(tracker.processChar("z") == .noKeyCandidate)
        }
        
        @Test func handlesExpectColonState() {
            var tracker = JSONKeyTracker(keys: ["name"])
            
            // Complete valid key
            tracker.processChar("{")
            tracker.processChar("\"")
            tracker.processChar("n")
            tracker.processChar("a")
            tracker.processChar("m")
            tracker.processChar("e")
            tracker.processChar("\"")
            
            // Now should expect colon
            #expect(tracker.processChar("x") == .expectColon) // Invalid character
            #expect(tracker.processChar(":") == .continue) // Valid colon
        }
    }
    
    // MARK: - KeyTrie Tests
    
    @Suite struct KeyTrieTests {
        @Test func buildsTrieCorrectly() {
            let trie = KeyTrie(keys: ["name", "age", "address"])
            
            // Test exact matches
            #expect(trie.getAllowedNextChars(prefix: "n") == Set(["a"]))
            #expect(trie.getAllowedNextChars(prefix: "na") == Set(["m"]))
            #expect(trie.getAllowedNextChars(prefix: "nam") == Set(["e"]))
            
            // Test terminal detection
            #expect(trie.isTerminal("name"))
            #expect(trie.isTerminal("age"))
            #expect(trie.isTerminal("address"))
            #expect(!trie.isTerminal("nam"))
        }
        
        @Test func handlesCommonPrefixes() {
            let trie = KeyTrie(keys: ["user", "username", "userinfo"])
            
            // Should allow branching at 'user'
            #expect(trie.getAllowedNextChars(prefix: "user").contains("n"))
            #expect(trie.getAllowedNextChars(prefix: "user").contains("i"))
        }
    }
    
    // MARK: - SchemaSnapParser Tests
    
    @Suite struct SchemaSnapParserTests {
        @Test func correctsDistance1Keys() throws {
            let parser = SchemaSnapParser()
            let schema = SchemaMeta(keys: ["name", "age", "email"], required: ["name"])
            
            let invalidJSON = """
            {"nane": "John", "age": 30}
            """
            
            let corrected = try parser.parse(invalidJSON, schema: schema)
            let expected = ["name": "John", "age": 30] as [String: Any]
            
            #expect(corrected["name"] as? String == expected["name"] as? String)
            #expect(corrected["age"] as? Int == expected["age"] as? Int)
        }
        
        @Test func normalizesKeysForMatching() throws {
            let parser = SchemaSnapParser()
            let schema = SchemaMeta(keys: ["user-name", "email_address"], required: [])
            
            let invalidJSON = """
            {"userName": "John", "emailaddress": "john@example.com"}
            """
            
            let corrected = try parser.parse(invalidJSON, schema: schema)
            
            #expect(corrected["user-name"] as? String == "John")
            #expect(corrected["email_address"] as? String == "john@example.com")
        }
        
        @Test func validatesRequiredFields() throws {
            let parser = SchemaSnapParser()
            let schema = SchemaMeta(keys: ["name", "age"], required: ["name"])
            
            let jsonMissingRequired = """
            {"age": 30}
            """
            
            #expect(throws: ConstraintError.self) {
                try parser.parse(jsonMissingRequired, schema: schema)
            }
        }
        
        @Test func throwsOnUncorrectableKeys() throws {
            let parser = SchemaSnapParser()
            let schema = SchemaMeta(keys: ["name", "age"], required: [])
            
            let jsonWithBadKey = """
            {"completely_wrong_key": "value"}
            """
            
            #expect(throws: ConstraintError.self) {
                try parser.parse(jsonWithBadKey, schema: schema)
            }
        }
    }
    
    // MARK: - RetryOrchestrator Tests
    
    @Suite struct RetryOrchestratorTests {
        @Test func retriesOnSchemaViolation() async throws {
            let orchestrator = RetryOrchestrator()
            let policy = ChatPolicy(retryMaxTries: 3)
            
            var attemptCount = 0
            let result = try await orchestrator.executeWithRetry(policy: policy) { attempt in
                attemptCount += 1
                if attempt < 3 {
                    throw ConstraintError.schemaViolation("Invalid format")
                }
                return "success"
            }
            
            #expect(result == "success")
            #expect(attemptCount == 3)
        }
        
        @Test func skipsRetryWithSeed() async throws {
            let orchestrator = RetryOrchestrator()
            let policy = ChatPolicy(retryMaxTries: 3)
            
            var attemptCount = 0
            
            #expect(throws: ConstraintError.self) {
                try await orchestrator.executeWithRetry(policy: policy, hasSeed: true) { attempt in
                    attemptCount += 1
                    throw ConstraintError.schemaViolation("Invalid format")
                }
            }
            
            // Should only attempt once when seed is provided
            #expect(attemptCount == 1)
        }
        
        @Test func propagatesNonRetryableErrors() async throws {
            let orchestrator = RetryOrchestrator()
            let policy = ChatPolicy(retryMaxTries: 3)
            
            var attemptCount = 0
            
            #expect(throws: NSError.self) {
                try await orchestrator.executeWithRetry(policy: policy) { attempt in
                    attemptCount += 1
                    throw NSError(domain: "Test", code: 1)
                }
            }
            
            // Should only attempt once for non-retryable errors
            #expect(attemptCount == 1)
        }
    }
    
    // MARK: - Integration Tests
    
    @Suite struct IntegrationTests {
        @Test func endToEndSCDFlow() async throws {
            // This would test the complete SCD flow when MLXBackend is implemented
            // For now, verify the component integration points exist
            
            let schema = SchemaMeta(keys: ["name", "age"], required: ["name"])
            let sampling = SamplingParameters(temperature: 0.7, maxTokens: 100)
            
            // Verify ConstrainedSampler can be constructed
            let tokenTrie = TokenTrie()
            let constrainedSampler = ConstrainedSampler(
                tokenTrie: tokenTrie,
                specialTokens: nil,
                keyTrie: nil
            )
            
            #expect(constrainedSampler != nil)
        }
        
        @Test func tokenTrieConstraintComputation() {
            let trie = TokenTrie()
            // Add some mock token sequences
            trie.insert(tokenIDs: [1, 2, 3], keyName: "name")
            trie.insert(tokenIDs: [4, 5], keyName: "age")
            
            let path = TokenTrie.Path(root: trie.root)
            let allowed = trie.getAllowedTokens(for: path)
            
            // Should include first tokens of all keys at root
            #expect(allowed.contains(1))
            #expect(allowed.contains(4))
        }
    }
}
